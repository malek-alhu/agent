import pytest
from langsmith import unit
from langchain_core.messages import AIMessage, ToolMessage

from react_agent import graph


@pytest.mark.asyncio
@unit
async def test_react_agent_simple_passthrough() -> None:
    res = await graph.ainvoke(
        {"messages": [("user", "Who is the founder of LangChain?")]},
        {"configurable": {"system_prompt": "You are a helpful AI assistant."}},
    )

    assert "harrison" in str(res["messages"][-1].content).lower()


@pytest.mark.asyncio
@unit
async def test_react_agent_btc_tool_flow() -> None:
    """Tests the full flow involving the get_btc_statistics tool and result processing."""
    # Use a system prompt that might encourage tool use if needed by the specific LLM
    config = {"configurable": {"system_prompt": "You are a helpful AI assistant that can fetch financial statistics using available tools."}}
    user_message = "Could you get the stats for BTCUSDT starting from 20240101?"

    # Invoke the graph
    res = await graph.ainvoke(
        {"messages": [("user", user_message)]},
        config,
    )

    messages = res["messages"]

    # --- Assertions ---

    # 1. Check for AIMessage with the correct tool call
    ai_tool_call_message = next((m for m in messages if isinstance(m, AIMessage) and m.tool_calls), None)
    assert ai_tool_call_message is not None, "AIMessage with tool_calls not found"
    assert len(ai_tool_call_message.tool_calls) == 1, "Expected exactly one tool call"
    tool_call = ai_tool_call_message.tool_calls[0]
    assert tool_call["name"] == "get_btc_statistics", "Tool name mismatch"
    assert tool_call["args"]["asset"] == "BTCUSDT", "Tool argument 'asset' mismatch"
    assert tool_call["args"]["start_date"] == "20240101", "Tool argument 'start_date' mismatch"
    # Optional: Check default value if necessary
    # assert tool_call["args"].get("bar_period", 1) == 1

    # 2. Check for ToolMessage containing the structured dictionary output
    tool_message = next((m for m in messages if isinstance(m, ToolMessage)), None)
    assert tool_message is not None, "ToolMessage not found"
    assert isinstance(tool_message.content, dict), "ToolMessage content should be a dict"
    assert "image_url" in tool_message.content, "Tool output missing 'image_url'"
    assert "metrics" in tool_message.content, "Tool output missing 'metrics'"
    assert "description" in tool_message.content, "Tool output missing 'description'"
    assert "BTCUSDT" in tool_message.content["description"], "Asset name missing in tool output description"
    assert tool_message.tool_call_id == ai_tool_call_message.tool_calls[0]['id'], "ToolMessage ID should match ToolCall ID"


    # 3. Check for the final AIMessage summary generated by process_tool_results
    # This should be the last message in the list after the ToolMessage
    final_ai_message = messages[-1]
    assert isinstance(final_ai_message, AIMessage), "Last message should be an AIMessage"
    assert not final_ai_message.tool_calls, "Final AIMessage should not contain tool calls"
    summary_content = final_ai_message.content.lower() # Use lower for case-insensitive checks
    assert "tool execution summary" in summary_content, "Summary prefix missing"
    assert "mock statistics" in summary_content, "Expected content from tool description missing"
    assert "btcusdt" in summary_content, "Asset name missing in summary"
    assert "20240101" in summary_content, "Start date missing in summary"
    assert "chart url" in summary_content, "Chart URL mention missing in summary"
    # Check if it references the tool call ID (optional but good practice)
    # assert tool_message.tool_call_id in final_ai_message.id # Check if summary ID relates to tool call
